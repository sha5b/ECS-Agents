#pragma kernel UpdateEnvironmentalVolume

// Input data
RWTexture3D<float4> VolumeTexture;
StructuredBuffer<float> Temperature;
StructuredBuffer<float> Moisture;
StructuredBuffer<float> WindSpeed;
StructuredBuffer<int> Biomes;

// Parameters
int3 GridSize;
int VisualizationType; // 0=Temperature, 1=Moisture, 2=WindSpeed, 3=Biomes

// Helper function to get 1D index from 3D position
int GetIndex(uint3 pos)
{
    return pos.x + GridSize.x * (pos.y + GridSize.y * pos.z);
}

// Normalize temperature from -20 to 40 range to 0-1
float NormalizeTemperature(float temp)
{
    return (temp + 20.0) / 60.0;
}

// Normalize wind speed from 0-20 range to 0-1
float NormalizeWindSpeed(float speed)
{
    return speed / 20.0;
}

// Normalize biome index to 0-1 range (9 biomes)
float NormalizeBiome(int biome)
{
    return (float)biome / 8.0;
}

// Color mapping functions
float4 TemperatureToColor(float temp)
{
    float t = NormalizeTemperature(temp);
    return float4(
        saturate(t * 2.0),     // Red
        saturate(1.0 - abs(t * 2.0 - 1.0)), // Green
        saturate(2.0 - t * 2.0),// Blue
        saturate(t * 0.5 + 0.5) // Alpha increases with temperature
    );
}

float4 MoistureToColor(float moisture)
{
    return float4(
        1.0 - moisture * 0.5,  // Red
        1.0 - moisture * 0.3,  // Green
        1.0,                   // Blue
        saturate(moisture * 0.7 + 0.3) // Alpha increases with moisture
    );
}

float4 WindSpeedToColor(float speed)
{
    float normalizedSpeed = NormalizeWindSpeed(speed);
    return float4(
        1.0 - normalizedSpeed * 0.5,  // Red
        1.0,                          // Green
        1.0 - normalizedSpeed * 0.5,  // Blue
        saturate(normalizedSpeed * 0.7 + 0.3) // Alpha increases with wind speed
    );
}

float4 BiomeToColor(int biome)
{
    switch(biome)
    {
        case 0: return float4(0.0, 0.2, 0.8, 0.8);    // Ocean
        case 1: return float4(0.9, 0.9, 0.6, 0.8);    // Beach
        case 2: return float4(0.5, 0.8, 0.3, 0.8);    // Plains
        case 3: return float4(0.2, 0.6, 0.2, 0.8);    // Forest
        case 4: return float4(0.0, 0.4, 0.0, 0.8);    // Jungle
        case 5: return float4(0.9, 0.8, 0.2, 0.8);    // Desert
        case 6: return float4(0.9, 0.9, 0.9, 0.8);    // Tundra
        case 7: return float4(0.5, 0.5, 0.5, 0.8);    // Mountain
        default: return float4(1.0, 1.0, 1.0, 0.8);   // Snow Peak
    }
}

[numthreads(8,8,8)]
void UpdateEnvironmentalVolume(uint3 id : SV_DispatchThreadID)
{
    // Check if within bounds
    if (any(id >= (uint3)GridSize))
        return;

    int index = GetIndex(id);
    float4 color;

    // Apply height-based alpha falloff
    float heightFactor = (float)id.y / GridSize.y;
    float alpha = saturate(1.0 - pow(heightFactor, 2.0));

    // Choose visualization based on type
    switch(VisualizationType)
    {
        case 0: // Temperature
            color = TemperatureToColor(Temperature[index]);
            break;
        case 1: // Moisture
            color = MoistureToColor(Moisture[index]);
            break;
        case 2: // Wind Speed
            color = WindSpeedToColor(WindSpeed[index]);
            break;
        case 3: // Biomes
            color = BiomeToColor(Biomes[index]);
            break;
        default:
            color = float4(1, 0, 1, 1); // Magenta for error
            break;
    }

    // Apply height-based alpha and increase overall visibility
    color.a *= alpha * 1.5;

    // Write to volume texture
    VolumeTexture[id] = color;
}
